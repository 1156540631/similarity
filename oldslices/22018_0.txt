static InputStream *get_input_stream(OutputStream *ost)
pts[index++] = av_rescale_q(c -> start,c -> time_base,avctx -> time_base) + t;
char error[1024];
ist = get_input_stream(ost);
ost -> st -> disposition = ist -> st -> disposition;
if (!oc -> oformat -> codec_tag || (av_codec_get_id(oc -> oformat -> codec_tag,icodec -> codec_tag)) == (codec -> codec_id) || !av_codec_get_tag2(oc -> oformat -> codec_tag,icodec -> codec_id,&codec_tag)) {
if (!strcmp(oc -> oformat -> name,"avi")) {
if (copy_tb < 0 && av_q2d(ist -> st -> r_frame_rate) >= av_q2d(ist -> st -> avg_frame_rate) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(ist -> st -> time_base) && 0.5 / av_q2d(ist -> st -> r_frame_rate) > av_q2d(icodec -> time_base) && av_q2d(ist -> st -> time_base) < 1.0 / 500 && av_q2d(icodec -> time_base) < 1.0 / 500 || copy_tb == 2) {
if (!(oc -> oformat -> flags & 0002000) && strcmp(oc -> oformat -> name,"mov") && strcmp(oc -> oformat -> name,"mp4") && strcmp(oc -> oformat -> name,"3gp") && strcmp(oc -> oformat -> name,"3g2") && strcmp(oc -> oformat -> name,"psp") && strcmp(oc -> oformat -> name,"ipod") && strcmp(oc -> oformat -> name,"f4v")) {
ost -> st -> avg_frame_rate = ist -> st -> avg_frame_rate;
ost -> enc = avcodec_find_encoder(codec -> codec_id);
snprintf(error,sizeof(error),"Encoder (codec %s) not found for output stream #%d:%d",avcodec_get_name(ost -> st -> codec -> codec_id),ost -> file_index,ost -> index);
int idx = av_find_nearest_q_idx(ost -> frame_rate,ost -> enc -> supported_framerates);
ost -> frame_rate = ost -> enc -> supported_framerates[idx];
codec -> channels = avfilter_link_get_channels(ost -> filter -> filter -> inputs[0]);
ost -> frame_rate = av_buffersink_get_frame_rate(ost -> filter -> filter);
codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ost -> frame_aspect_ratio?av_d2q((ost -> frame_aspect_ratio * (codec -> height) / (codec -> width)),255) : ost -> filter -> filter -> inputs[0] -> sample_aspect_ratio);
parse_forced_key_frames(ost -> forced_keyframes,ost,ost -> st -> codec);
if (!strcmp(ost -> enc -> name,"libx264")) {
ost = output_streams[i];
if (ist = get_input_stream(ost)) {
ost -> st -> codec -> subtitle_header = (av_mallocz((dec -> subtitle_header_size + 1)));
memcpy((ost -> st -> codec -> subtitle_header),(dec -> subtitle_header),(dec -> subtitle_header_size));
ost -> st -> codec -> subtitle_header_size = dec -> subtitle_header_size;
if ((ret = avcodec_open2(ost -> st -> codec,codec,&ost -> opts)) < 0) {
if (ist = get_input_stream(ost)) {
snprintf(error,sizeof(error),"Error while opening encoder for output stream #%d:%d - maybe incorrect parameters such as bit_rate, rate, width or height",ost -> file_index,ost -> index);
av_buffersink_set_frame_size(ost -> filter -> filter,(ost -> st -> codec -> frame_size));
av_opt_set_dict((ost -> st -> codec),&ost -> opts);
if (ist = get_input_stream(ost)) {
for (i = 0; i < nb_output_files; i++) {
oc = output_files[i] -> ctx;
oc -> interrupt_callback = int_cb;
if ((ret = avformat_write_header(oc,&output_files[i] -> opts)) < 0) {
char errbuf[128];
const char *errbuf_ptr = errbuf;
if (av_strerror(ret,errbuf,sizeof(errbuf)) < 0) {
errbuf_ptr = (strerror(-ret));
snprintf(error,sizeof(error),"Could not write header for output file #%d (incorrect codec parameters ?): %s",i,errbuf_ptr);
if (strcmp(oc -> oformat -> name,"rtp")) {
if ((ret = avformat_write_header(oc,&output_files[i] -> opts)) < 0) {
if (av_strerror(ret,errbuf,sizeof(errbuf)) < 0) {
errbuf_ptr = (strerror(-ret));
snprintf(error,sizeof(error),"Could not write header for output file #%d (incorrect codec parameters ?): %s",i,errbuf_ptr);
static InputStream *get_input_stream(OutputStream *ost)
if (ist = get_input_stream(ost)) {
static InputStream *get_input_stream(OutputStream *ost)
if (ist = get_input_stream(ost)) {
static InputStream *get_input_stream(OutputStream *ost)
if (ist = get_input_stream(ost)) {
static InputStream *get_input_stream(OutputStream *ost)
if (ist = get_input_stream(ost)) {
snprintf(error,sizeof(error),"Error while opening encoder for output stream #%d:%d - maybe incorrect parameters such as bit_rate, rate, width or height",ost -> file_index,ost -> index);
snprintf(error,sizeof(error),"Could not write header for output file #%d (incorrect codec parameters ?): %s",i,errbuf_ptr);
static void parse_forced_key_frames(char *kf,OutputStream *ost,AVCodecContext *avctx)
parse_forced_key_frames(ost -> forced_keyframes,ost,ost -> st -> codec);
if (ist = get_input_stream(ost)) {
static void parse_forced_key_frames(char *kf,OutputStream *ost,AVCodecContext *avctx)
ost = output_streams[i];
ist = get_input_stream(ost);
codec -> width = ost -> filter -> filter -> inputs[0] -> w;
codec -> height = ost -> filter -> filter -> inputs[0] -> h;
codec -> sample_aspect_ratio = ost -> st -> sample_aspect_ratio = (ost -> frame_aspect_ratio?av_d2q((ost -> frame_aspect_ratio * (codec -> height) / (codec -> width)),255) : ost -> filter -> filter -> inputs[0] -> sample_aspect_ratio);
parse_forced_key_frames(ost -> forced_keyframes,ost,ost -> st -> codec);
AVCodecContext *dec = ((void *)0);
if (ist = get_input_stream(ost)) {
memcpy((ost -> st -> codec -> subtitle_header),(dec -> subtitle_header),(dec -> subtitle_header_size));
if ((ret = avcodec_open2(ost -> st -> codec,codec,&ost -> opts)) < 0) {
if (ist = get_input_stream(ost)) {
