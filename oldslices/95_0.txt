wcsncpy(aResultDir, argvTmp[2], MAX_PATH);
bool backgroundUpdate = IsUpdateBeingStaged(argcTmp, argvTmp);
LOAD_LIBRARY_AS_DATAFILE);
HMODULE updaterModule = LoadLibraryEx(argv[0], NULL,
if (!LoadStringA(updaterModule, IDS_UPDATER_IDENTITY,
FreeLibrary(updaterModule);
if (!PathRemoveFileSpecW(serviceUpdaterPath)) {
if (!PathAppendSafe(serviceUpdaterPath, L"update")) {
CreateDirectoryW(serviceUpdaterPath, NULL);
if (!PathAppendSafe(serviceUpdaterPath, L"updater.exe")) {
result = DeleteFileW(serviceUpdaterPath);
serviceUpdaterPath));
if (PathGetSiblingFilePath(updaterINIPath, serviceUpdaterPath,
WCHAR secureUpdaterPath[MAX_PATH + 1] = { L'\0' };
result = GetSecureUpdaterPath(secureUpdaterPath);
oldUpdaterPath, secureUpdaterPath));
DeleteSecureUpdater(secureUpdaterPath);
argv[3] = secureUpdaterPath;
result = ProcessSoftwareUpdateCommand(argc - 3, argv + 3);
IsUpdateBeingStaged(int argc, LPWSTR *argv)
return argc == 4 && !wcscmp(argv[3], L"-1");
bool replaceRequest = (argcTmp >= 4 && wcsstr(argvTmp[3], L"/replace"));
if (!IsLocalFile(argv[0], isLocal) || !isLocal) {
nsAutoHandle noWriteLock(CreateFileW(argv[0], GENERIC_READ, FILE_SHARE_READ,
if (result && !VerifySameFiles(argv[0], installDirUpdater,
HMODULE updaterModule = LoadLibraryEx(argv[0], NULL,
if (!LoadStringA(updaterModule, IDS_UPDATER_IDENTITY,
FreeLibrary(updaterModule);
DeleteSecureUpdater(WCHAR serviceUpdaterPath[MAX_PATH + 1])
result = CopyFileW(oldUpdaterPath, secureUpdaterPath, FALSE);
argv[3] = secureUpdaterPath;
result = ProcessSoftwareUpdateCommand(argc - 3, argv + 3);
ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv)
if (!GetInstallationDir(argc, argv, installDir)) {
GetInstallationDir(int argcTmp, LPWSTR *argvTmp, WCHAR aResultDir[MAX_PATH + 1])
if (!IsLocalFile(argv[0], isLocal) || !isLocal) {
nsAutoHandle noWriteLock(CreateFileW(argv[0], GENERIC_READ, FILE_SHARE_READ,
if (result && !VerifySameFiles(argv[0], installDirUpdater,
HMODULE updaterModule = LoadLibraryEx(argv[0], NULL,
if (!LoadStringA(updaterModule, IDS_UPDATER_IDENTITY,
FreeLibrary(updaterModule);
BOOL PathGetSiblingFilePath(LPWSTR destinationBuffer,  LPCWSTR siblingFilePath,
result = CopyFileW(oldUpdaterPath, secureUpdaterPath, FALSE);
argv[3] = secureUpdaterPath;
result = ProcessSoftwareUpdateCommand(argc - 3, argv + 3);
GetSecureUpdaterPath(WCHAR serviceUpdaterPath[MAX_PATH + 1])
if (!GetModuleFileNameW(NULL, serviceUpdaterPath, MAX_PATH)) {
argv[3] = secureUpdaterPath;
result = ProcessSoftwareUpdateCommand(argc - 3, argv + 3);
