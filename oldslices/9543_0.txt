appendEscapedContent(result, ucharRange(node, range), documentIsHTML);
static inline pair<const UChar*, size_t> ucharRange(const Node *node, const Range *range)
appendUCharRange(result, ucharRange(node, range));
if (node == range->endContainer(ec))
length = range->endOffset(ec);
if (node == range->startContainer(ec)) {
size_t start = range->startOffset(ec);
String createMarkup(const Range* range, Vector<Node*>* nodes, EAnnotateForInterchange annotate, bool convertBlocksToInlines)
Document* document = range->ownerDocument();
Frame* frame = document->frame();
DeleteButtonController* deleteButton = frame ? frame->editor()->deleteButtonController() : 0;
RefPtr<Range> updatedRange = avoidIntersectionWithNode(range, deleteButton ? deleteButton->containerElement() : 0);
bool collapsed = updatedRange->collapsed(ec);
Node* commonAncestor = updatedRange->commonAncestorContainer(ec);
Node* pastEnd = updatedRange->pastLastNode();
Node* startNode = updatedRange->firstNode();
VisiblePosition visibleStart(updatedRange->startPosition(), VP_DEFAULT_AFFINITY);
VisiblePosition visibleEnd(updatedRange->endPosition(), VP_DEFAULT_AFFINITY);
markups.append(getStartMarkup(n, updatedRange.get(), annotate));
preMarkups.append(getStartMarkup(parent, updatedRange.get(), annotate));
Node* fullySelectedRoot = body && areRangesEqual(VisibleSelection::selectionFromContentsOfNode(body).toNormalizedRange().get(), updatedRange.get()) ? body : 0;
preMarkups.append(getStartMarkup(ancestor, updatedRange.get(), annotate, convertBlocksToInlines, 0, DoesNotFullySelectNode));
static String getStartMarkup(const Node* node, const Range* range, EAnnotateForInterchange annotate, bool convertBlocksToInlines = false, HashMap<AtomicStringImpl*, AtomicStringImpl*>* namespaces = 0, RangeFullySelectsNode rangeFullySelectsNode = DoesFullySelectNode)
appendStartMarkup(result, node, range, annotate, convertBlocksToInlines, namespaces, rangeFullySelectsNode);
static void appendStartMarkup(Vector<UChar>& result, const Node* node, const Range* range, EAnnotateForInterchange annotate, bool convertBlocksToInlines = false, HashMap<AtomicStringImpl*, AtomicStringImpl*>* namespaces = 0, RangeFullySelectsNode rangeFullySelectsNode = DoesFullySelectNode)
appendUCharRange(result, ucharRange(node, range));
appendEscapedContent(result, ucharRange(node, range), documentIsHTML);
String markup = escapeContentText(useRenderedText ? renderedText(node, range) : stringValueForRange(node, range), false);
static String stringValueForRange(const Node* node, const Range* range)
ExceptionCode ec;
if (node == range->endContainer(ec))
str.truncate(range->endOffset(ec));
if (node == range->startContainer(ec))
str.remove(0, range->startOffset(ec));
