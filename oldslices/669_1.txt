static int ws_snd_decode_frame(AVCodecContext *avctx, void *data,
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {
samples     = s->frame.data[0];
count = *buf & 0x3F;
case 0:  smp = 4;                              break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
code = *buf++;
sample = av_clip_uint8(sample);
*samples++ = sample;
sample += ((code >> 2) & 0x3) - 2;
sample = av_clip_uint8(sample);
*samples++ = sample;
sample += ((code >> 4) & 0x3) - 2;
sample = av_clip_uint8(sample);
*samples++ = sample;
sample +=  (code >> 6)        - 2;
sample = av_clip_uint8(sample);
*samples++ = sample;
code = *buf++;
count = *buf & 0x3F;
case 0:  smp = 4;                              break;
case 1:  smp = 2;                              break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
code = *buf++;
sample += ( code       & 0x3) - 2;
sample = av_clip_uint8(sample);
*samples++ = sample;
sample += ws_adpcm_4bit[code & 0xF];
sample = av_clip_uint8(sample);
*samples++ = sample;
sample += ws_adpcm_4bit[code >> 4];
sample = av_clip_uint8(sample);
*samples++ = sample;
t = count;
t <<= 3;
sample += t >> 3;
sample = av_clip_uint8(sample);
*samples++ = sample;
memcpy(samples, buf, smp);
samples += smp;
memcpy(samples, buf, smp);
buf     += smp;
memcpy(samples, buf, smp);
sample = buf[-1];
sample = av_clip_uint8(sample);
*samples++ = sample;
memcpy(samples, buf, smp);
memset(samples, sample, smp);
samples += smp;
memcpy(samples, buf, smp);
