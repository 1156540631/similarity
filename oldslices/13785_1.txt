nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
unionType myUnion;
myUnion.unionFirst = fc;
nsFloatCache * fc = myUnion.unionSecond;
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
