base = CG_BASE(cg);
next = CG_NEXT(cg);
offset = PTRDIFF(next, base, jsbytecode);
js_ReportOutOfScriptQuota(cx);
return -1;
return offset;
pc = CG_CODE(cg, target);
op = (JSOp) *pc;
cs = &js_CodeSpec[op];
extern uint8 js_opcode2extra[];
extra = js_opcode2extra[op];
((cs->format & JOF_TMPSLOT_MASK) >> JOF_TMPSLOT_SHIFT) +
depth = (uintN) cg->stackDepth +
extra;
depth = (uintN) cg->stackDepth +
cg->maxStackDepth = depth;
nuses = js_GetStackUses(cs, op, pc);
cg->stackDepth -= nuses;
JS_ASSERT(cg->stackDepth >= 0);
JS_ReportErrorFlagsAndNumber(cx, JSREPORT_WARNING,
ndefs = cs->ndefs;
blockObj = cg->objectList.lastbox->object;
JS_ASSERT(STOBJ_GET_CLASS(blockObj) == &js_BlockClass);
JS_ASSERT(JSVAL_IS_VOID(blockObj->fslots[JSSLOT_BLOCK_DEPTH]));
OBJ_SET_BLOCK_DEPTH(cx, blockObj, cg->stackDepth);
ndefs = OBJ_BLOCK_COUNT(cx, blockObj);
cg->stackDepth += ndefs;
cg->maxStackDepth = cg->stackDepth;
UpdateDepth(cx, cg, offset);
ptrdiff_t offset = EmitCheck(cx, cg, op, 2);
jsbytecode *next = CG_NEXT(cg);
UpdateDepth(cx, cg, offset);
jsbytecode *next = CG_NEXT(cg);
UpdateDepth(cx, cg, offset);
ptrdiff_t offset = EmitCheck(cx, cg, op, length);
jsbytecode *next = CG_NEXT(cg);
UpdateDepth(cx, cg, offset);
JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NEED_DIET,
jt = *jtp;
jt2 = jt->kids[otherDir];
*jtp = root = jt2->kids[dir];
*jtp = root = jt->kids[otherDir];
jt = cg->jtFreeList;
jt->offset = args->offset;
jt->balance = 0;
jt->kids[JT_LEFT] = jt->kids[JT_RIGHT] = NULL;
*jtp = jt;
? 1 - BalanceJumpTargets(jtp)
JS_ASSERT(-1 <= jt->balance && jt->balance <= 1);
JS_ASSERT(jt->balance == rh - lh);
ReportStatementTooLarge(cx, cg);
AddJumpTarget(&args, &cg->jumpTargets);
AVLCheck(cg->jumpTargets);
index = cg->numSpanDeps;
ReportStatementTooLarge(cx, cg);
(!(sdbase = cg->spanDeps) || index >= SPANDEPS_MIN)) {
size = sdbase ? SPANDEPS_SIZE(index) : SPANDEPS_SIZE_MIN / 2;
sdbase = (JSSpanDep *) JS_realloc(cx, sdbase, size + size);
cg->spanDeps = sdbase;
cg->numSpanDeps = index + 1;
sd->top = PTRDIFF(pc, CG_BASE(cg), jsbytecode);
sd->offset = sd->before = PTRDIFF(pc2, CG_BASE(cg), jsbytecode);
ReportStatementTooLarge(cx, cg);
if (!SetSpanDepTarget(cx, cg, sd, off))
if (!AddSpanDep(cx, cg, pc, pc2, off))
pc = AddSwitchSpanDeps(cx, cg, pc);
if (!AddSpanDep(cx, cg, pc, pc, off))
UpdateJumpTargets(jt->kids[JT_LEFT], pivot, delta);
UpdateJumpTargets(jt->kids[JT_RIGHT], pivot, delta);
UpdateJumpTargets(cg->jumpTargets, sd2->offset,
JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
ts->filename ? ts->filename : "stdin", cg->firstLine,
growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
sd2 = FindNearestSpanDep(cg, target,
if (!js_SetSrcNoteOffset(cx, cg, noteIndex, i, span))
jmp = js_Emit3(cx, cg, op, JUMP_OFFSET_HI(off), JUMP_OFFSET_LO(off));
pc = CG_CODE(cg, jmp);
if (!AddSpanDep(cx, cg, pc, pc, off))
if (!BuildSpanDepTable(cx, cg))
return SetSpanDepTarget(cx, cg, GetSpanDep(cg, pc), off);
stmt->flags = 0;
stmt->blockid = tc->blockid();
stmt->label = NULL;
JS_ASSERT(!stmt->blockObj);
stmt->down = tc->topStmt;
if (STMT_LINKS_SCOPE(stmt)) {
tc->topScopeStmt = stmt;
stmt->downScope = NULL;
js_PushStatement(tc, stmt, STMT_BLOCK, top);
stmt->flags |= SIF_SCOPE;
stmt->downScope = tc->topScopeStmt;
tc->topScopeStmt = stmt;
depth = cg->stackDepth;
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (EmitBackPatchOp(cx, cg, JSOP_BACKPATCH, &GOSUBS(*stmt)) < 0)
if (js_Emit1(cx, cg, JSOP_LEAVEWITH) < 0)
if (js_Emit1(cx, cg, JSOP_ENDITER) < 0)
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
i = OBJ_BLOCK_COUNT(cx, stmt->blockObj);
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
cg->stackDepth = depth;
if (!EmitNonLocalJumpFixup(cx, cg, toStmt))
index = js_NewSrcNote2(cx, cg, noteType, (ptrdiff_t) ALE_INDEX(label));
valueAtom = js_AtomizeDouble(cx, dval);
ale = cg->constList.add(cg->compiler, atom);
JS_ASSERT(cg->flags & TCF_COMPILE_N_GO);
ok = OBJ_LOOKUP_PROPERTY(cx, obj, ATOM_TO_JSID(atom), &objbox,
ok = OBJ_GET_ATTRIBUTES(cx, obj, ATOM_TO_JSID(atom), prop,
ok = OBJ_GET_PROPERTY(cx, obj, ATOM_TO_JSID(atom), vp);
OBJ_DROP_PROPERTY(cx, objbox, prop);
} while ((cg = (JSCodeGenerator *) cg->parent) != NULL);
if (js_Emit1(cx, cg, (JSOp)(JSOP_INDEXBASE1 + indexBase - 1)) < 0)
if (js_Emit2(cx, cg, JSOP_INDEXBASE, (JSOp)indexBase) < 0)
bigSuffix = EmitBigIndexPrefix(cx, cg, index);
return bigSuffix == JSOP_NOP || js_Emit1(cx, cg, bigSuffix) >= 0;
return js_Emit1(cx, cg, JSOP_LENGTH) >= 0;
ale = cg->atomList.add(cg->compiler, pn->pn_atom);
return EmitIndexOp(cx, op, ALE_INDEX(ale), cg);
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
JS_ASSERT((jsuint) slot < cg->maxStackDepth);
slot += cg->fun->u.i.nvars;
js_ReportCompileErrorNumber(cx, CG_TS(cg), NULL,
slot = -1;
if (!EmitObjectOp(cx, pn->pn_objbox, JSOP_ENTERBLOCK, cg))
JSObject *blockObj = pn->pn_objbox->object;
jsint depth = AdjustBlockSlot(cx, cg, OBJ_BLOCK_DEPTH(cx, blockObj));
limit = slot + OBJ_BLOCK_COUNT(cx, blockObj);
js_ReallocSlots(cx, blockObj, JSSLOT_FREE(&js_BlockClass), JS_TRUE);
JSContext *cx = cg->compiler->context;
uintN upvarLevel = fun->u.i.script->staticLevel;
JSLocalKind localKind = js_LookupLocal(cx, fun, atom, &index);
JS_ASSERT(cg->staticLevel > upvarLevel);
JSAtomListElement *ale = cg->upvarList.lookup(atom);
!js_AddLocal(cx, cg->fun, atom, JSLOCAL_UPVAR)) {
ale = cg->upvarList.add(cg->compiler, atom);
JS_ASSERT(ALE_INDEX(ale) == cg->upvarList.count - 1);
uint32 *vector = cg->upvarMap.vector;
uint32 length = cg->upvarMap.length;
JS_ASSERT(ALE_INDEX(ale) <= length);
if (ALE_INDEX(ale) == length) {
length = 2 * JS_MAX(2, length);
vector = (uint32 *) JS_realloc(cx, vector, length * sizeof *vector);
cg->upvarMap.vector = vector;
cg->upvarMap.length = length;
vector[ALE_INDEX(ale)] = MAKE_UPVAR_COOKIE(skip, index);
pn->pn_op = JSOP_GETUPVAR;
pn->pn_cookie = MAKE_UPVAR_COOKIE(cg->staticLevel, ALE_INDEX(ale));
pn->pn_dflags |= PND_BOUND;
JS_ASSERT(pn->pn_type == TOK_NAME);
JS_ASSERT(pn->pn_op != JSOP_ARGUMENTS && pn->pn_op != JSOP_CALLEE);
JS_ASSERT(pn->pn_cookie == FREE_UPVAR_COOKIE);
pn->pn_dflags |= (dn->pn_dflags & PND_CONST);
op = PN_OP(pn);
JS_ASSERT(JOF_OPTYPE(op) == JOF_ATOM);
cookie = dn->pn_cookie;
JS_ASSERT(cg->flags & TCF_COMPILE_N_GO);
pn->pn_op = JSOP_FALSE;
pn->pn_dflags |= PND_BOUND;
if (pn->isConst())
pn->pn_op = op = JSOP_NAME;
JS_ASSERT(cg->flags & TCF_COMPILE_N_GO);
? STOBJ_GET_PARENT(FUN_OBJECT(cg->fun))
return MakeUpvarForEval(pn, cg);
case JSOP_NAME:     op = JSOP_GETGVAR; break;
case JSOP_SETNAME:  op = JSOP_SETGVAR; break;
case JSOP_INCNAME:  op = JSOP_INCGVAR; break;
case JSOP_NAMEINC:  op = JSOP_GVARINC; break;
case JSOP_DECNAME:  op = JSOP_DECGVAR; break;
case JSOP_NAMEDEC:  op = JSOP_GVARDEC; break;
pn->pn_op = op;
pn->pn_cookie = cookie;
pn->pn_dflags |= PND_BOUND;
uintN level = UPVAR_FRAME_SKIP(cookie);
JS_ASSERT(cg->staticLevel >= level);
JS_ASSERT(cg->staticLevel >= level);
pn->pn_op = JSOP_GETUPVAR;
pn->pn_cookie = cookie;
pn->pn_dflags |= PND_BOUND;
return MakeUpvarForEval(pn, cg);
JS_ASSERT(cg->flags & TCF_IN_FUNCTION);
JS_ASSERT(cg->lexdeps.lookup(atom));
if (FUN_FLAT_CLOSURE(cg->fun)) {
op = JSOP_GETDSLOT;
op = JSOP_GETUPVAR;
ale = cg->upvarList.lookup(atom);
index = ALE_INDEX(ale);
if (!js_AddLocal(cx, cg->fun, atom, JSLOCAL_UPVAR))
ale = cg->upvarList.add(cg->compiler, atom);
index = ALE_INDEX(ale);
JS_ASSERT(index == cg->upvarList.count - 1);
uint32 *vector = cg->upvarMap.vector;
uint32 length = cg->lexdeps.count;
if (!vector || cg->upvarMap.length != length)
vector = (UpvarCookie *) js_realloc(vector, length * sizeof *vector);
JS_ReportOutOfMemory(cx);
cg->upvarMap.vector = vector;
cg->upvarMap.length = length;
pn->pn_op = op;
pn->pn_cookie = index;
pn->pn_dflags |= PND_BOUND;
case JSOP_NAME:     op = JSOP_GETLOCAL; break;
case JSOP_SETNAME:  op = JSOP_SETLOCAL; break;
case JSOP_INCNAME:  op = JSOP_INCLOCAL; break;
case JSOP_NAMEINC:  op = JSOP_LOCALINC; break;
case JSOP_DECNAME:  op = JSOP_DECLOCAL; break;
case JSOP_NAMEDEC:  op = JSOP_LOCALDEC; break;
case JSOP_FORNAME:  op = JSOP_FORLOCAL; break;
case JSOP_NAME:     op = JSOP_GETARG; break;
case JSOP_SETNAME:  op = JSOP_SETARG; break;
case JSOP_INCNAME:  op = JSOP_INCARG; break;
case JSOP_NAMEINC:  op = JSOP_ARGINC; break;
case JSOP_DECNAME:  op = JSOP_DECARG; break;
case JSOP_NAMEDEC:  op = JSOP_ARGDEC; break;
case JSOP_FORNAME:  op = JSOP_FORARG; break;
JS_ASSERT(!pn->isConst());
JS_ASSERT(op != JSOP_CALLEE);
JS_ASSERT((cg->fun->flags & JSFUN_LAMBDA) && atom == cg->fun->atom);
JS_ASSERT(op != JSOP_DELNAME);
op = JSOP_CALLEE;
pn->pn_dflags |= PND_CONST;
pn->pn_op = op;
pn->pn_dflags |= PND_BOUND;
case JSOP_NAME:     op = JSOP_GETLOCAL; break;
case JSOP_SETNAME:  op = JSOP_SETLOCAL; break;
case JSOP_SETCONST: op = JSOP_SETLOCAL; break;
case JSOP_INCNAME:  op = JSOP_INCLOCAL; break;
case JSOP_NAMEINC:  op = JSOP_LOCALINC; break;
case JSOP_DECNAME:  op = JSOP_DECLOCAL; break;
case JSOP_NAMEDEC:  op = JSOP_LOCALDEC; break;
case JSOP_FORNAME:  op = JSOP_FORLOCAL; break;
JS_ASSERT(op != PN_OP(pn));
pn->pn_op = op;
pn->pn_cookie = UPVAR_FRAME_SLOT(cookie);
pn->pn_dflags |= PND_BOUND;
JSAtomListElement *ale = cg->atomList.add(cg->compiler, pn->pn_atom);
if (!EmitIndexOp(cx, JSOP_QNAMEPART, ALE_INDEX(ale), cg))
JS_ASSERT(pn->pn_arity == PN_NAME);
pn2 = pn->maybeExpr();
if (!BindNameToSlot(cx, cg, pn2))
top = CG_OFFSET(cg);
if (!js_EmitTree(cx, cg, pndown))
if (js_NewSrcNote2(cx, cg, SRC_PCBASE,
if (!EmitSpecialPropOp(cx, pndot, JSOP_GETELEM, cg))
} else if (!EmitAtomOp(cx, pndot, PN_OP(pndot), cg)) {
if (!js_EmitTree(cx, cg, pn2))
if (js_NewSrcNote2(cx, cg, SRC_PCBASE,
JSParseNode *left, *right, *next, ltmp, rtmp;
JS_ASSERT(pn->pn_op == JSOP_GETELEM);
JS_ASSERT(pn->pn_count >= 3);
left = pn->pn_head;
right = pn->last();
next = left->pn_next;
JS_ASSERT(next != right);
if (!BindNameToSlot(cx, cg, left))
next = left->pn_next;
JS_ASSERT(next != right || pn->pn_count == 3);
if (!js_EmitTree(cx, cg, left))
if (!js_EmitTree(cx, cg, next))
left = &ltmp;
JS_ASSERT(ATOM_IS_STRING(pn->pn_atom));
right->pn_op = js_IsIdentifier(ATOM_TO_STRING(pn->pn_atom))
JS_ASSERT(pn->pn_arity == PN_BINARY);
if (!BindNameToSlot(cx, cg, left))
if (!js_EmitTree(cx, cg, left))
if (!js_EmitTree(cx, cg, right))
return js_Emit1(cx, cg, JSOP_ZERO) >= 0;
return js_Emit1(cx, cg, JSOP_ONE) >= 0;
return js_Emit2(cx, cg, JSOP_INT8, (jsbytecode)(int8)ival) >= 0;
off = js_EmitN(cx, cg, JSOP_UINT24, 3);
pc = CG_CODE(cg, off);
off = js_EmitN(cx, cg, JSOP_INT32, 4);
pc = CG_CODE(cg, off);
atom = js_AtomizeDouble(cx, dval);
ale = cg->atomList.add(cg->compiler, atom);
return EmitIndexOp(cx, JSOP_DOUBLE, ALE_INDEX(ale), cg);
JSStmtInfo *stmtInfo)
count = OBJ_BLOCK_COUNT(cx, pn2->pn_objbox->object);
js_PushBlockScope(cg, stmtInfo, pn2->pn_objbox->object, -1);
stmtInfo->type = STMT_SWITCH;
if (!EmitEnterBlock(cx, pn2, cg))
if (!js_EmitTree(cx, cg, pn->pn_left))
js_PushStatement(cg, stmtInfo, STMT_SWITCH, top);
atom = js_AtomizeDouble(cx, d);
ok = LookupCompileTimeConstant(cx, cg, pn4->pn_atom, &v);
atom = js_AtomizeDouble(cx, d);
JS_malloc(cx,
ok = LookupCompileTimeConstant(cx, cg, pn4->pn_atom, &v);
JS_free(cx, intmap);
noteIndex = js_NewSrcNote3(cx, cg, SRC_SWITCH, 0, 0);
if (js_EmitN(cx, cg, switchOp, switchSize) < 0)
if (pn4 && !js_EmitTree(cx, cg, pn4))
if (!js_SetSrcNoteOffset(cx, cg, (uintN)caseNoteIndex, 0,
caseNoteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
off = EmitJump(cx, cg, JSOP_CASE, 0);
noteCount = CG_NOTE_COUNT(cg);
if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 1,
noteCountDelta = CG_NOTE_COUNT(cg) - noteCount;
!js_SetSrcNoteOffset(cx, cg, (uintN)caseNoteIndex, 0,
defaultOffset = EmitJump(cx, cg, JSOP_DEFAULT, 0);
pc = CG_CODE(cg, top + JUMP_OFFSET_LEN);
table = (JSParseNode **) JS_malloc(cx, tableSize);
if (!AddSwitchSpanDeps(cx, cg, CG_CODE(cg, top)))
savepc = CG_NEXT(cg);
if (js_NewSrcNote2(cx, cg, SRC_LABEL, (ptrdiff_t)
if (js_NewSrcNote2(cx, cg, SRC_LABEL, (ptrdiff_t)
ok = js_EmitTree(cx, cg, pn4);
off = CG_OFFSET(cg) - top;
ok = js_SetJumpOffset(cx, cg, CG_CODE(cg, defaultOffset),
ok = js_SetJumpOffset(cx, cg, pc, off);
off = CG_OFFSET(cg) - top;
ok = js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, off);
ale = cg->atomList.add(cg->compiler, pn->pn_atom);
if (!UpdateLineNumberNotes(cx, cg, pn->pn_pos.begin.lineno))
CG_SWITCH_TO_MAIN(cg);
if (!emitter(cx, cg, prologOp, pn2))
if (!emitter(cx, cg, prologOp, pn3))
pn = pn->pn_kid;
if (!EmitDestructuringOpsHelper(cx, cg, pn))
if (!BindNameToSlot(cx, cg, pn))
if (pn->isConst() && !pn->isInitialized())
return js_Emit1(cx, cg, JSOP_POP) >= 0;
if (!EmitElemOp(cx, pn, JSOP_ENUMELEM, cg))
if (!EmitElemOp(cx, pn, JSOP_ENUMCONSTELEM, cg))
top = CG_OFFSET(cg);
if (!js_EmitTree(cx, cg, pn))
if (js_Emit1(cx, cg, JSOP_ENUMELEM) < 0)
intN stackDepth = cg->stackDepth;
JS_ASSERT(stackDepth != 0);
if (js_Emit1(cx, cg, JSOP_DUP) < 0)
if (!EmitNumberOp(cx, index, cg))
JS_ASSERT(pn2->pn_type == TOK_COLON);
if (js_NewSrcNote(cx, cg, SRC_INITPROP) < 0)
if (!EmitNumberOp(cx, pn3->pn_dval, cg))
pn3 = pn2->pn_right;
if (js_Emit1(cx, cg, JSOP_GETELEM) < 0)
JS_ASSERT(cg->stackDepth == stackDepth + 1);
JS_ASSERT(pn2 == pn3);
for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
pn3 = pn2;
if (!EmitDestructuringLHS(cx, cg, pn3))
JS_ASSERT(cg->stackDepth == stackDepth);
JS_ASSERT(cg->stackDepth == stackDepth + 1);
if (!EmitDestructuringLHS(cx, cg, pn3))
return EmitDestructuringOpsHelper(cx, cg, pn);
depth = limit = (uintN) cg->stackDepth;
if (!js_EmitTree(cx, cg, pn))
i = depth;
JS_ASSERT(i < limit);
jsint slot = AdjustBlockSlot(cx, cg, i);
if (js_Emit1(cx, cg, JSOP_POP) < 0)
if (!EmitDestructuringLHS(cx, cg, pn))
JS_ASSERT(pn->pn_type == TOK_ASSIGN);
JSParseNode *pn, JSOp *pop)
lhs = pn->pn_left;
if (!EmitGroupAssignment(cx, cg, prologOp, lhs, rhs))
JSParseNode *lhs, JSParseNode *rhs)
for (pn = lhs->pn_head; pn; pn = pn->pn_next, ++i) {
if (!EmitDestructuringLHS(cx, cg, pn))
off = noteIndex = -1;
if (!EmitDestructuringDecls(cx, cg, PN_OP(pn), pn2))
JS_ASSERT(pn2->pn_left->pn_type == TOK_NAME);
JS_ASSERT(noteIndex < 0 && !pn2->pn_next);
if (!MaybeEmitGroupAssignment(cx, cg,
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
if (!EmitDestructuringDecls(cx, cg, PN_OP(pn), pn3))
if (!js_EmitTree(cx, cg, pn2->pn_right))
pn3 = pn2->maybeExpr();
if (!BindNameToSlot(cx, cg, pn2))
if (!MaybeEmitVarDecl(cx, cg, PN_OP(pn), pn2, &atomIndex))
!js_DefineCompileTimeConstant(cx, cg, pn2->pn_atom, pn3)) {
if (!js_EmitTree(cx, cg, pn3))
js_NewSrcNote2(cx, cg, SRC_DECL,
if (js_Emit1(cx, cg, op) < 0)
tmp = CG_OFFSET(cg);
if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, tmp-off))
noteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
index = CG_NOTE_COUNT(cg);
if (((uintN)index & CG_NOTE_MASK(cg)) == 0) {
if (!CG_NOTES(cg)) {
js_ReportOutOfScriptQuota(cx);
return -1;
return index;
index = AllocSrcNote(cx, cg);
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (EmitBackPatchOp(cx, cg, JSOP_BACKPATCH, &GOSUBS(*stmt)) < 0)
return -1;
sn = &CG_NOTES(cg)[index];
offset = CG_OFFSET(cg);
delta = offset - CG_LAST_NOTE_OFFSET(cg);
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (!EmitNonLocalJumpFixup(cx, cg, toStmt))
index = js_NewSrcNote2(cx, cg, noteType, (ptrdiff_t) ALE_INDEX(label));
index = AllocSrcNote(cx, cg);
return -1;
sn = &CG_NOTES(cg)[index];
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (!EmitNonLocalJumpFixup(cx, cg, toStmt))
index = js_NewSrcNote2(cx, cg, noteType, (ptrdiff_t) ALE_INDEX(label));
if (js_NewSrcNote(cx, cg, SRC_NULL) < 0)
return -1;
return index;
index = js_NewSrcNote(cx, cg, type);
if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset))
return -1;
noteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
JS_ASSERT(noteIndex < 0 && !pn2->pn_next);
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
pn3 = pn2->maybeExpr();
if (!BindNameToSlot(cx, cg, pn2))
return index;
noteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
JS_ASSERT(noteIndex < 0 && !pn2->pn_next);
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
pn3 = pn2->maybeExpr();
if (!BindNameToSlot(cx, cg, pn2))
if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset1))
if (!js_SetSrcNoteOffset(cx, cg, index, 1, offset2))
js_ReportOutOfScriptQuota(cx);
sn = &CG_NOTES(cg)[index];
JS_ASSERT(SN_TYPE(sn) != SRC_XDELTA);
for (sn++; which; sn++, which--) {
if (((CG_NOTE_COUNT(cg) + 1) & CG_NOTE_MASK(cg)) <= 1) {
index = PTRDIFF(sn, CG_NOTES(cg), jssrcnote);
if (!GrowSrcNotes(cx, cg))
if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset))
if (js_NewSrcNote2(cx, cg, SRC_PCBASE, CG_OFFSET(cg) - top) < 0)
if (!EmitDestructuringLHS(cx, cg, pn3))
if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset1))
noteIndex = js_NewSrcNote3(cx, cg, SRC_SWITCH, 0, 0);
if (js_EmitN(cx, cg, switchOp, switchSize) < 0)
sn = CG_NOTES(cg) + index;
diff = CG_NOTE_COUNT(cg) - (index + 3);
if (!js_SetSrcNoteOffset(cx, cg, noteIndex, i, span))
sd2 = FindNearestSpanDep(cg, target,
sn += 2;
index = PTRDIFF(sn, CG_NOTES(cg), jssrcnote);
if (((CG_NOTE_COUNT(cg) + 1) & CG_NOTE_MASK(cg)) <= 1) {
sn = CG_NOTES(cg) + index;
diff = CG_NOTE_COUNT(cg) - (index + 3);
JS_ASSERT(diff >= 0);
memmove(sn + 3, sn + 1, SRCNOTE_SIZE(diff));
