size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,
packet.dataPtr = frame_buffer + offset;
const size_t kH264NALHeaderLengthInBytes = 1;
const size_t kLengthFieldLength = 2;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
size_t length = BufferToUWord16(nalu_ptr);
nalu_ptr += kLengthFieldLength;
frame_buffer_ptr += Insert(nalu_ptr,
length,
const_cast<uint8_t*>(packet.dataPtr));
size_t length,
uint8_t* frame_buffer) {
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum))) {
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_))) {
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_)) {
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
int VCMSessionInfo::InsertPacket(const VCMPacket& packet,
uint8_t* frame_buffer,
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum)) {
last_packet_seq_num_ = static_cast<int>(packet.seqNum);
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
if (packets_.size() == kMaxPacketsInSession) {
ReversePacketIterator rit = packets_.rbegin();
for (; rit != packets_.rend(); ++rit)
if (rit != packets_.rend() &&
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
VCMPacket& packet = *packet_it;
size_t offset = 0;
offset += (*it).sizeBytes;
const uint8_t* packet_buffer = packet.dataPtr;
packet.dataPtr = frame_buffer + offset;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
uint8_t* frame_buffer_ptr = frame_buffer + offset;
nalu_ptr += length;
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
length += (insert_start_code ? kH264StartCodeLengthBytes : 0);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
const_cast<uint8_t*>(packet.dataPtr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
size_t VCMSessionInfo::Insert(const uint8_t* buffer,
buffer,
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
